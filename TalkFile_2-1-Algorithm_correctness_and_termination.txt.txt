アルゴリズムの正しさを、アルゴリズムの正当性(出力結果の正しさ)、ならび
に、停止性(いかなる入力の場合でも、有限時間で停止すること)の観点から説
明する。

■アルゴリズムの正当性

階乗計算の漸化式との対応関係により、アルゴリズムの正当性を検証する。

まず、階乗計算の漸化式は次のように定義される。

  0! = 1
  (i+1)! = (i+1)*(i!)  (i=0,1,2,...)

この漸化式は、iの初期値を0として、iの値を1ずつ増加していき、iの値がn-1
となるまで二番目の式を繰り返し計算をすることにより、n!の計算ができるこ
とを示している。

一方で、計算のフローチャートにおいては、
  i  を 変数i、
  i! を 変数factorial、
に対応させ、iが0からn-1の間で1ずつ増加させて、代入

  factorial ← (i+1)*factorial

を繰り返し計算している。
変数factorialの初期値は、1となっており、iが0のときのi!の値(0! = 1)で正
しく初期化されている。
また、任意のiに対して、factorialの値がi!であるときに、

  (i+1) * factrial

の値は、先の漸化式の右辺と同じであるので、その計算結果は、(i+1)!である
ことが保証される。この値を代入した、更新後のfactorialの値も、(i+1)!の
値であることが保証される。さらに、上記の繰り返し計算において、上記代入
が一番最後に行われるときには、i = n-1となっている。よって、繰り返し計
算後のfactorialの値は、((n-1)+1)! = n!の値となっていることが保証される。

変数factorialが無限精度の整数であれば、上記の計算で正しい。一方で、C言
語のint型においては、表現しうる数の範囲に限界があるため、乗算計算におい
てオーバーフロー(桁溢れ)が起こり、計算結果が表現できる範囲を超える可能
性がある。

具体的には、i+1の値、factroalの値がそれぞれ、int型の表現範囲内であると
しても、

  (i+1) * factrial

の計算結果が表現範囲を超える可能性がある。iが条件

  i+1 ≦ (int型整数の最大値)/(factorialの値)

を満たすのであれば、

  (i+1) * factrial

の計算結果も「int型整数の最大値」以下であることが保証され、オーバーフ
ローがおこらない。iの値が上記条件を満たした時にのみ乗算を行うとすれば、
代入

  factorial ← (i+1)*factorial

による更新後のfactorialの値が、(i+1)!の値を示していることが保証される。


■ アルゴリズムの停止性

nの値によって場合分けをし、停止性を検証する。

・n<0の場合

  最初の条件分岐にて、Yes側に分岐し、エラーメッセージを出力して停止する。

・0≦ n ≦ m の場合(整数mは、m ≦ (int型整数の最大値)/(m-1)! なる最大の整数)

  i=0を初期値として、二番目の条件分岐をYes側に分岐することによりループ
  を繰り返すが、ループを繰り返すたびにiがひとつずつ増える。二番目の条
  件分岐には2つの条件がある。

  一つ目の条件は、右辺が定数であり、左辺がiで単調増加あるので、ループ
  の繰り返しが進行すれば、いずれ満足されなくなる。

　二つ目の条件は、factorialが増加するので、右辺は単調減少、左辺がi+1で
  単調増加であるので、ループの繰り返しが進行すれば、いずれ満足されなく
  なる。

  そのため、ループの繰り返しが進行すれば、いずれNo側に分岐することがわ
  かる。

　0≦ n ≦ mにおいては、一つ目の条件が先に満たされなくなり、No側に分岐
  する。一つ目の条件が満たされないことは、「i<nではない」という状況な
  ので、i≧nと等価である。そのため、三番目の条件分岐の条件は満たされる
  ので、Yes側に分岐し、factorialの値を出力して停止する。

・n>mの場合

  0≦ n ≦mの場合とほぼ同じであるが、一つ目の条件より先に二つ目の条件が
  満たされなくなる。そのため、三番目の条件分岐においては、「i<nである」
  という状況であるので、条件はみたされず、No側に分岐し、エラーメッセー
  ジを表示して最初のnの入力に戻る。


上記より、n≦mなるnがいずれ入力されることを前提とすれば、このアルゴリ
ズムは停止する。

以上
